<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

  </body>
</html>
<script type="text/javascript">
  //插入排序

  //从数组的第二个开始 依次与前面的成员比较  将大于当前元素的成员后移 自身插入到第一个比他小的成员前面
    //example [8,4,7,4,2,7,4]
    //1:[4,8,7,4,2,7,4]
    //2:[4,7,8,4,2,7,4]
    //3:[4,4,7,8,2,7,4]
    //4:[2,4,4,7,8,7,4]
    //        ...
  function insertionSort(arr) {
      for (var i = 1; i < arr.length; i++) {
          var element = arr[i];
          for (var j = i - 1; j >= 0; j--) {
              var tmp = arr[j];
              var order = tmp - element;
              if (order > 0) {
                  arr[j + 1] = tmp;
              } else {
                  break;
              }
          }
          arr[j + 1] = element;
      }
      return arr;
  }

内连接查询
select *(table_1.a,b,c,table_2.x,y,z/table_1.*---选择两个表规定的字段) from tablle_1 inner join table_2 on table_1.a=table_2.x where table_1.id>100;
找到table_1中满足条件的数据 合并匹配上的需要的table_2中的字段 这种会筛去满足不了条件的table_1数据（如果table_2中没有任何数据能和table_1匹配）


左连接
select * from table_1 left join table_2 on  table_1.a=table_2.x where table_1.id>100;
在内连接查询的基础上 保存匹配不了的table_1数据  而为匹配的table_2数据的字段值为null 并不会筛选table_1的数据


右连接
select * from table_1 right join table_2 on  table_1.a=table_2.x where table_1.id>100;
与左连接相反 保留table_2的数据


















//这种排序的时间复杂度为 O(n)~O(n*n)
</script>
