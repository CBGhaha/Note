<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

  </body>
</html>
<script type="text/javascript">
  /*
    js的浅拷贝
  */
  var obj={
    name:'a',
    innerObj:{
      key:'inner',
      arr:[1,2,3,4]
    }
  }
  // 1: Object.assign  Object.assign只做了一层的深拷贝 即对象的属性如果也是引用数据则新对象属性引用旧对象的属性值  只拷贝原对象自身可枚举属性
  var obj2=Object.assign({},obj);
  obj2.name='b';
  obj2.innerObj.key='out';
  console.log(obj);
  console.log(obj2);
  //2:拓展运算符拷贝 其本质和Object.assign一样 只进行了一层深拷贝
  var obj3={...obj};
  //3:数组的slice和concat 只能拷贝基本数据类型的成员 对于引用类型的成员还是引用

  /*
    js的深拷贝
  */

  //1:JSON.parse(JSON.stringify()) 将对象转化为string 再转化为对象 JSON.stringify()只会字符化对象自身的可枚举的属性
  //但是这样有一些缺陷（并不能处理以下属性）：
  // 1、会忽略 `undefined`
  // 2、会忽略 `symbol`
  // 3、不能序列化函数
  // 4、不能解决循环引用的对象
  // 5、不能正确处理`new Date()`
  // 6、不能处理正则

//2:手写一个深拷贝
  /*
    1：参数判断 必须为非null的object类型数据
    2：for in 遍历对象
    3：创建新对象或新数组
    4：判断属性是否来自对象自身 是则复制属性
    5：递归调用
    6：增加属性为引用对象的处理（属性来自其他对象的引用 或自身的引用 如果不处理则会复制一个新对象则拷贝失真  或者进入死循环）
    7：增加对symbol属性的处理
    
  */
</script>
