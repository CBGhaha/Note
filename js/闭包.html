<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

  </body>
</html>
<script type="text/javascript">

//闭包就是能够读取其他函数内部变量的函数。--阮一峰
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
console.log(checkscope()());
//这里F1，f1是两个函数 但是在F1内部拿到了f1中定义的a变量

//闭包有两个应用场景
// 1:可以读取函数内部的变量，
// 2另一个就是让这些变量的值始终保持在内存中。


// 第一种应用场景可以是 定义私有变量
function Person(){
  var name='bang';
  var age=25;
  this.getName=function(firstName){
    return firstName+name;
  }
  this.getAge=function(month){
    return age+'-'+month;
  }
}

// 这里我创建了一个构造函数 我在函数中声明了name和age变量
// 在外部我无法修改这个变量 但我通过getName和getAge这两个方法函数向外暴露了name和age
// 其实这相当于解决了js没有私有属性的缺点
var person=new Person();
console.log(person.getName('chen'));
console.log(person.getAge(4));

/***************************************************/
//第二种应用场景是函数的柯里化
function curry(fun,...rest){
  var argList=rest||[];
  return function CC(arg){
    if(arg){
      argList.push(arg);
      return CC;
    }else{
      return fun(...argList);
    }
  }
}

function fun(...rest){
  console.log(rest)
}
let resultFun=curry(fun,1,2)(3)(4);
resultFun();
//这个柯里化函数比较特殊 柯里化构造函数在判断最后没有实参传入后再会终止继续柯里化 并将所有保存起来的实参给fun调用
// 在这里可以看到resultFun是一个函数 这个函数拿到了所有之前函数传入的实参



</script>
