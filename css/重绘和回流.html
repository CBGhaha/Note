<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>重构和回流</title>
  </head>
  <body>

  </body>
</html>
<script type="text/javascript">
//1： 解析HTML，生成DOM树，解析CSS，生成CSSOM树
//2： 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
//3： Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
//4： Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
//5： Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）

// dom树包含页面的所有标签节点包括head和隐藏标签
// 渲染树不包含隐藏标签并且每个标签节点包含了他的样式css属性
// 重绘：
//   当渲染树中的元素的样式发生变化 但是结构没有变化的时候发生重绘
// 回流:
//   当渲染树中的元素的结构发生变化时候发生回流及重绘
//    dom元素的位置和尺寸大小的变化
//    dom元素的增加和删除
//    伪类的激活
//    浏览器窗口大小的变化
//    修改class


//  回流一定重绘 但重绘不一定回流
//优化：
/*
使用 transform 替代 top
使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局
避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。
尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。
将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。
避免使用CSS表达式，可能会引发回流。
将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。
CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

*/


</script>
