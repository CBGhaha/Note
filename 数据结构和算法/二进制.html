<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>
</html>
<script>

  //js中的number 数据
  /**
   * js number类型 采用双精度64位浮点型
   * 64位分为
   * 符号位S 指数域P 尾数域M
   *   1位    11位    52位
   * 计算方式为
   * （-1)^S*2(p-1023)*M
   * 
   * js能表示的最大numebr是 2^53 即P和M都为最大值
  */


  // 十进制和二进制的转换
  /**
   * 1.正整数转二进制
   * 每次除以二取余数，直到商为0或1
   *     商          余数
   *     23           1
   *     11           1
   *      5           1  
   *      2           0
   *      1           
   * 结果10111
   * 
   * 2.负整数转二进制
   *  取正整数的源码的补码 
   *  23 用一个字节表示为 00010111
   *  反码：11101000
   *  补码：11101001
   *  
   * 
   * 2.正小数转二进制
   * 用当前积乘以2 省略整数位 直到积为1
   * 0.7*2  1.4   1
   * 0.4*2  0.8   0
   * 0.8*2  1.6   1
   * 0.6*2  1.2   1
   * 0.2*2  0.4   0
   * 0.4*2  0.8   0
   * 0.8*2  1.6   1
   * 0.6*2  1.2   1
   * ... 无尽 所以基于js的双进度64位浮点型的内存表示0.7是无法准确表示的 
   * 
   * 0.25*2 0.5   0
   * 0.5*2  1     
   * 结果为0.01
   * 
   * 
   * 
   * 
   * 
   * 
  */
  var findKthLargest = function(nums, k) {
    for(let i = 0; i<=k; i++){
      debugger
        for(let j = 0; j<nums.length-1; j++){
            const item = nums[j];
            const nextItem = nums[j+1];
            if(item>nextItem){
                [nums[j], nums[j+1]] = [nums[j+1], nums[j]];
            }
        }
    }
    return nums[nums.length-k];
};
findKthLargest([7,6,5,4,3,2,1], 2)

</script>